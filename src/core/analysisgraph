#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Dec  4 09:25:32 2020

@author: khs3z
"""

import pandas as pd
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
import random
from concurrent.futures import ThreadPoolExecutor, Future
import time

class AnalysisNode():
    
    def __init__(self, data, description):
        self.data = data
        self.description = description
        pass
    
    def __repr__(self):
        return self.description

    def show():
        pass
        
class AnalysisStep():
    
    def __init__(self, config):
        self.config = config
        self.inputs = []
        self.outputs = []
    
    def get_name(self):
        return "abstract process"
        
    def set_inputs(self, inp):
        self.inputs = inp
        
    def get_outputs(self):
        return self.outputs
    
    def apply(self):
        self.outputs = self.inputs
        return self.outputs
    
    def __repr__(self):
        return f"{self.get_name()}"


class CreateColumn(AnalysisStep):
    
    def get_name(self):
        return "Create Column"
    
    def apply(self):
        if self.config['inplace']:
            data = self.inputs[0]
        else:
            data = self.inputs[0].copy()
        col = data[self.config['col_in']] + self.config['value']
        col.name = self.config['col_out']
        self.outputs = [col]
        return self.outputs

        
class Merge(AnalysisStep):

    def get_name(self):
        return "Merge Columns"
    
    def apply(self):
        self.outputs = [pd.concat(self.inputs, axis=1)]
        return self.outputs
        
        
        
def random_dag(nodes, edges):
    """Generate a random Directed Acyclic Graph (DAG) with a given number of nodes and edges."""
    G = nx.DiGraph()
    for i in range(nodes):
        G.add_node(i)
    while edges > 0:
        a = random.randint(0,nodes-1)
        b=a
        while b==a:
            b = random.randint(0,nodes-1)
        G.add_edge(a,b)
        if nx.is_directed_acyclic_graph(G):
            edges -= 1
        else:
            # we closed a loop!
            G.remove_edge(a,b)
    return G

def randomwait():
    pass
    
if __name__ == "__main__":
    df = pd.DataFrame(np.random.rand(4,3), columns=["A", "B", "C"])
    cfg = {'col_in':'A', 'col_out':'Result', 'operation':'add', 'value':10, 'inplace':False}
    s = CreateColumn(cfg)
    s.set_inputs([df])
    new_df = s.apply()
    print (new_df)
    print (df)
    
    cfg = {}
    merge = Merge(cfg)

    graph = nx.DiGraph()
    graph.add_edges_from([("root", "a"), ("a", "b"), ("a", "e"), ("b", "c"), ("b", "d"), ("d", "e"), ("b", "f")])
    plt.tight_layout()
    nx.draw_networkx(graph, arrows=True)
    plt.show()
    #plt.savefig("g1.png", format="PNG")
    # tell matplotlib you're done with the plot: https://stackoverflow.com/questions/741877/how-do-i-tell-matplotlib-that-i-am-done-with-a-plot
    plt.clf()
    
    graph = nx.DiGraph(descr="Summary")
    initialStep = AnalysisStep({})
    initialStep.set_inputs([df])
    graph.add_node(1, action=initialStep)
    graph.add_node(2, action=CreateColumn({'col_in':'A', 'col_out':'D', 'operation':'add', 'value':10, 'inplace':False}))
    graph.add_node(3, action=CreateColumn({'col_in':'B', 'col_out':'E', 'operation':'add', 'value':20, 'inplace':False}))
    graph.add_node(4, action=CreateColumn({'col_in':'C', 'col_out':'F', 'operation':'add', 'value':30, 'inplace':False}))
    graph.add_node(5, action=merge)
    graph.add_edge(1, 2, color='yellow')
    graph.add_edge(1, 3, color='yellow')
    graph.add_edge(1, 4, color='yellow')
    graph.add_edge(1, 5, color='yellow')
    graph.add_edge(2, 5, color='yellow')
    graph.add_edge(3, 5, color='yellow')
    graph.add_edge(4, 5, color='yellow')
    print (graph.nodes.data())
    nx.draw_networkx(graph, arrows=True)
    plt.show()
    plt.clf()
    
    #G = random_dag(32,128)
    futures = {}
    analyses = nx.classes.function.get_node_attributes(graph, 'action')
    with ThreadPoolExecutor(max_workers=1) as executor:
        for node in nx.topological_sort(graph):
            predecessors = list(graph.predecessors(node))
            inputs = []
            for p in predecessors:
                inputs.extend(futures[p])
            print (node, predecessors)
            if (len(inputs)>0):
                analyses[node].set_inputs(inputs)
            futures[node] = analyses[node].apply()
#            future = executor.submit(pow, 323, 1235)
#            print(future.result())
    print (futures[5])